# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!! THIS WILL NEED A DEDICATED TEST !!

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class _dcNode:
    def __init__(self, name):
        self.v = None
        self._name = name
    def __getattr__(self, key):
        name = '{}.{}'.format(self._name, key)
        self.__dict__[key] = _dcNode(name)
        return self.__dict__[key]
    def __setattr__(self, key, value):
        self.__dict__[key] = value
    def _(self, key):
        k = key
        if isinstance(key, int):
            k = '_' + str(key)
        name = '{}.{}'.format(self._name, k)
        if k not in self.__dict__:
            self.__dict__[k] = _dcNode(name)
        return self.__dict__[k]
def _dcdump(node=None, path=''):
    if not node: node = dc
    if node.v is not None:
        if node.v == '':
            print('dc.' + path + '.v =  \'\'')
        else:
            print('dc.' + path + '.v = ', node.v)
    for x in node.__dict__.keys():
        if isinstance(node.__dict__[x], _dcNode):
            _dcdump(node=node.__dict__[x], path=path + bool(path)*'.' + x)
dc = _dcNode('dc')

def _testGenerateDc(
                # (major, minor, open f, total f, open i, total f)
    milestones, # ((0, 1, 0, 1, 0, 1), (0, 2, 0, 1, 0, 1),
                #  (1, 0, 0, 1, 0, 1), (1, 2, 0, 3, 0, 3))
    active,     # (0, 1)
    selected):  # (1, 1))

    versions = ''
    for major, minor, fc, ft, ic, it in milestones:

        versions += '{}.{} [{}/{}, {}/{}]'.format(major, minor, fc, ft, ic, it)
        if (major, minor) == active:
            versions += ' (a)'
        if (major, minor) == selected:
            versions += ' (s)'
        versions += '\n'

    print(versions)

    dc.sp.m.mi.nextid.v   = 1
    dc.sp.m.mi.index.v    = {}
    dc.sp.m.active.v      = active
    dc.sp.m.selected.v    = selected
    dc.sp.m.index.v       = set()

    for major, minor, fc, ft, ic, it in milestones:

        dc.sp.m.index.v |= {major}

        if not isinstance(dc.sp.m._(major).index.v, set):
            dc.sp.m._(major).index.v = {minor}
        else:
            dc.sp.m._(major).index.v |= {minor}

        for x in range(fc):

            miid = dc.sp.m.mi.nextid.v
            dc.sp.m.mi.nextid.v += 1
            dc.sp.m.mi.index.v[miid] = (major, minor)

            dc.sp.m.mi._(miid).mtype.v = 'Feature'
            dc.sp.m.mi._(miid).status.v = 'Closed'

            if not isinstance(dc.sp.m._(major)._(minor).index.v, set):
                dc.sp.m._(major)._(minor).index.v = {miid}
            else:
                dc.sp.m._(major)._(minor).index.v |= {miid}

        for x in range(ft - fc):

            miid = dc.sp.m.mi.nextid.v
            dc.sp.m.mi.nextid.v += 1
            dc.sp.m.mi.index.v[miid] = (major, minor)

            dc.sp.m.mi._(miid).mtype.v = 'Feature'
            dc.sp.m.mi._(miid).status.v = 'Open'

            if not isinstance(dc.sp.m._(major)._(minor).index.v, set):
                dc.sp.m._(major)._(minor).index.v = {miid}
            else:
                dc.sp.m._(major)._(minor).index.v |= {miid}

        for x in range(ic):

            miid = dc.sp.m.mi.nextid.v
            dc.sp.m.mi.nextid.v += 1
            dc.sp.m.mi.index.v[miid] = (major, minor)

            dc.sp.m.mi._(miid).mtype.v = 'Issue'
            dc.sp.m.mi._(miid).status.v = 'Closed'

            if not isinstance(dc.sp.m._(major)._(minor).index.v, set):
                dc.sp.m._(major)._(minor).index.v = {miid}
            else:
                dc.sp.m._(major)._(minor).index.v |= {miid}

        for x in range(it - ic):

            miid = dc.sp.m.mi.nextid.v
            dc.sp.m.mi.nextid.v += 1
            dc.sp.m.mi.index.v[miid] = (major, minor)

            dc.sp.m.mi._(miid).mtype.v = 'Issue'
            dc.sp.m.mi._(miid).status.v = 'Open'

            if not isinstance(dc.sp.m._(major)._(minor).index.v, set):
                dc.sp.m._(major)._(minor).index.v = {miid}
            else:
                dc.sp.m._(major)._(minor).index.v |= {miid}

    _dcdump()

def _testComputeMinorLabelItems():

    _testGenerateDc(
            ((0, 1, 0, 1, 0, 1),
             (0, 2, 0, 1, 0, 1),
             (1, 0, 0, 1, 0, 1),
             (1, 1, 0, 3, 1, 3)),
            (0, 1),
            (1, 1))

_testComputeMinorLabelItems()

## ;

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

for miid in dc.sp.m._(major)._(minor).index.v:

    if dc.sp.m.mi._(miid).mtype == 'Feature':
        out.total_features += 1

        if dc.sp.m.mi._(miid).status.v == 'Open':
            out.open_features += 1

    if dc.sp.m.mi._(miid).mtype == 'Issue':
        out.total_issues += 1

        if dc.sp.m.mi._(miid).status.v == 'Open':
            out.open_issues += 1

    amajor, aminor = dc.sp.m.active.v

    if major > amajor:
        out.diamond = '◆'
        out.delta_sign = '-'
        out.delta_major = amajor - major

        inCurrent = aminor
        inBetween = 0
        for x in range(major+1, amajor):
            inBetween += len(dc.sp.m._(x).index.v)

        #     0.1 0.2 0.3 0.4   len(0) -> 3  0.2   len(0) - 2 = 1
        # 1.0 1.1 1.2 1.3 1.4   len(1) -> 4  0.2   len(1) - 2 = 2

        inMajor = len(dc.sp.m._(major).index.v) - minor
        if major == 0:
            inMajor += 1

        out.delta_minor = inCurrent + inBetween + inMajor

    elif major < amajor:
        out.diamond = '◇'
        out.delta_sign = '+'
        out.delta_major = major - amajor

        #     0.1 0.2 0.3 0.4   len(0) -> 3  0.2   3 - 2 = 1
        # 1.0 1.1 1.2 1.3 1.4   len(1) -> 4  0.2   4 - 2 = 2

        inCurrent = len(dc.sp.m._(amajor).index.v) - aminor
        if amajor == 0:
            inCurrent += 1

        inBetween = 0
        for x in range(amajor+1, major):
            inBetween += len(dc.sp.m._(x).index.v)
        inMajor = minor

        out.delta_minor = inCurrent + inBetween + inMajor

    else:

        out.delta_major = 0

        if minor > aminor:
            out.diamond = '◆'
            out.delta_sign = '-'
            out.delta_minor = aminor - minor

        elif minor < aminor:
            out.diamond = '◇'
            out.delta_sign = '+'
            out.delta_minor = 0

        else:
            out.diamond = '◈'
            out.delta_sign = '+'
            out.delta_minor = minor - aminor

    out.label = '{}  v{}.{}  {}{}:{}   f:{}/{}  i:{}/{}'.format(
                    out.diamond,
                    major,
                    minor,
                    out.delta_sign,
                    out.delta_major,
                    out.delta_minor,
                    out.open_features,
                    out.total_features,
                    out.open_issues,
                    out.total_issues)

    return out

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

